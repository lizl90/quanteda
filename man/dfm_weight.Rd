% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfm_weight.R
\name{dfm_weight}
\alias{dfm_weight}
\alias{dfm_smooth}
\title{Weight the feature frequencies in a dfm}
\usage{
dfm_weight(x, scheme = c("count", "prop", "propmax", "logcount", "boolean",
  "augmented", "logave"), weights = NULL, base = 10, K = 0.5)

dfm_smooth(x, smoothing = 1)
}
\arguments{
\item{x}{document-feature matrix created by \link{dfm}}

\item{scheme}{a label of the weight type:
\describe{
  \item{\code{count}}{\eqn{tf_{ij}}, an integer feature count (default when a dfm is created)}
  \item{\code{prop}}{the proportion of the feature counts of total feature
  counts (aka relative frequency), calculated as \eqn{tf_{ij} / \sum_j tf_{ij}}}
  \item{\code{propmax}}{the proportion of the feature counts of the highest
  feature count in a document, \eqn{tf_{ij} / \textrm{max}_j tf_{ij}}}
  \item{\code{logcount}}{take the logarithm of 1 + each count, for base
  \code{base}: \eqn{\textrm{log}_{base}(1 + tf_{ij})}}
  \item{\code{boolean}}{recode all non-zero counts as 1}
  \item{\code{augmented}}{equivalent to \eqn{K + (1 - K) *} \code{dfm_weight(x,
  "propmax")}}
  \item{\code{logave}}{1 + the log of the counts) / (1 + log of the counts / the average count within document), or
  \deqn{\frac{1 + \textrm{log}_{base} tf_{ij}}{1 + \textrm{log}_{base}(\sum_j tf_{ij} / N_i)}}}
}}

\item{weights}{if \code{scheme} is unused, then \code{weights} can be a named
numeric vector of weights to be applied to the dfm, where the names of the
vector correspond to feature labels of the dfm, and the weights will be
applied as multipliers to the existing feature counts for the corresponding
named features.  Any features not named will be assigned a weight of 1.0
(meaning they will be unchanged).}

\item{base}{base for the logarithm when \code{scheme} is \code{"logcount"} or 
\code{logave}}

\item{K}{the K for the augmentation when \code{scheme = "augmented"}}

\item{smoothing}{constant added to the dfm cells for smoothing, default is 1}
}
\value{
\code{dfm_weight} returns the dfm with weighted values.  Note the
  because the default weighting scheme is \code{"count"}, simply calling this
  function on an unweighted dfm will return the same object.  Many users will
  want the normalized dfm consisting of the proportions of the feature counts
  within each document, which requires setting \code{scheme = "prop"}.

\code{dfm_smooth} returns a dfm whose values have been smoothed by
  adding the \code{smoothing} amount. Note that this effectively converts a
  matrix from sparse to dense format, so may exceed memory requirements
  depending on the size of your input matrix.
}
\description{
Weight the feature frequencies in a dfm
}
\examples{
dtm <- dfm(data_corpus_inaugural)

x <- apply(dtm, 1, function(tf) tf/max(tf))
topfeatures(dtm)
normDtm <- dfm_weight(dtm, "prop")
topfeatures(normDtm)
maxTfDtm <- dfm_weight(dtm, scheme = "propmax")
topfeatures(maxTfDtm)
logTfDtm <- dfm_weight(dtm, scheme = "logcount")
topfeatures(logTfDtm)
logaveDtm <- dfm_weight(dtm, scheme = "logave")
topfeatures(logaveDtm)

# combine these methods for more complex dfm_weightings, e.g. as in Section 6.4
# of Introduction to Information Retrieval
head(dfm_tfidf(dtm, scheme_tf = "logcount"))

# apply numeric weights
str <- c("apple is better than banana", "banana banana apple much better")
(mydfm <- dfm(str, remove = stopwords("english")))
dfm_weight(mydfm, weights = c(apple = 5, banana = 3, much = 0.5))

\dontshow{
testdfm <- dfm(data_corpus_inaugural[1:5])
for (w in  c("count", "prop", "propmax", "logcount", "boolean", "augmented", "logave")) {
    testw <- dfm_weight(testdfm, w)
    cat("\\n\\n=== weight() TEST for:", w, "; class:", class(testw), "\\n")
    head(testw)
}}
# smooth the dfm
dfm_smooth(mydfm, 0.5)
}
\references{
Manning, Christopher D., Prabhakar Raghavan, and Hinrich Schutze.
  \emph{Introduction to Information Retrieval}. Vol. 1. Cambridge: Cambridge 
  University Press, 2008.
}
\seealso{
\code{\link{dfm_tfidf}}, \code{\link{docfreq}}
}
\keyword{dfm}
